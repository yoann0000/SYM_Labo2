4.1
Si le Serveur ne répond pas, le SymComManager resterait bloqué lorsqu'il essaie de recevoir la réponse. Cela pourrait être un problème si celle-ci n'arrive 
jamais (perte de message). Pour régler ce problème, il faudrait plutôt ouvrir un nouveau thread pour le SymComManager et rajouter un nouveau thread timeout,
qui attend x seconde, regarde si le SymComManager est arrété et si ce n'est pas le cas, l'arrête et affiche une erreur "serveur indisponible"
Dans le cas où nous recevons un message d'erreur, ce dernier ne ferait qu'afficher ce qu'il reçoit. (Il n'y a aucun contrôle sur le code de réponse). Nous
pouvons simplement vérifier le code réponse du serveu via un connection.getResponseCode() puis envoyer un message différent selon si elle désigne une erreur
ou si la réponse du serveur est correcte.

=======
﻿4.1
On pourrai faire que le communication manager ne return pas null si la comunication echoue mais retourne une string d'erreur comme ça l'on pourrai créer des clauses dans le code pour gérer les differentes strings d'erreurs.
4.2
On peut utiliser un protocole asyncrone sous condition que l'authentification se fasse en synchrone.
Par exemple, on s'authentifie ce qui nous donnerai un token d'access puis toute les autres requetes ce feraient à l'aide de ce token.
Idem pour différé pour autant que le token ne s'expire pas.

Oui, c'est possible. Il suffit de rajouter un header Authorization contenant notre crédential (en admettant que nous en ayons une), il faut aussi que
l'application côté serveur permette ce genre d'authentification. Pour les requêtes différées, cela est aussi possible, mais il faut faire en sorte que
l'utilisateur n'ait pas à rentrer ses credentials quand le serveur devient disponible.

4.3
un probleme de concurrence. Il faut faire en sorte que les processus soient synchronisés de sortes à ce que nous ne perdions pas de données ni lors de 
l'envoi (qu'une ancienne préparation se fasse écraser par une nouvelle avant qu'elle ne soit envoyée), ni lors de la réception (qu'une donnée reçue se 
fasse écraser par une nouvelle avant qu'elle ne soit traitée)

4.4
Effectuer une connexion par transmission différée 
 
Multiplexer toutes les connexions vers un même serveur en une seule connexion de transport. Dans ce dernier cas, comment implémenter
 le protocole applicatif, quels avantages peut-on espérer de ce multiplexage, et surtout, comment doit-on planifier les réponses du 
serveur lorsque ces dernières s'avèrent nécessaires ? 
Une seule connexion 

4.5.a
REST/JSON est moins secure v donc serai vulnerable a des attaques si le code derrière n'est pas secure

4.5.b
les protocol buffers sont compatibles avec HTTP. le protocol buffer pourrait serialiser un objet en une requete http pour l'envoyer.

4.6
	   "Test" "Lorem Ipsum (premier paragraphe)" "Lorem Ipsum (entier)"
Async    : 129	  230				     Crash
Compress : 309	  287				     348
On constate qu'après une certaine taille l'asynctask plante alors que le format compressé ne plante pas. On constate aussi que pour du texte simple,
les performances sont meilleures sans compression. Toutefois, plus le texte est long plus le temps d'attente entre l'envois de la requête et le temps
de réception de la réponse sera long (sans parler des problèmes d'erreurs si le texte est trop long). Dans la version compressée, on constate que le temps 
d'envoi et de réception est stable quelque soit la longueur du texte.
